<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="None">
  
  <link rel="shortcut icon" href="img/favicon.ico">
  <title>Home - Auditorium</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="css/theme.css" type="text/css" />
  <link rel="stylesheet" href="css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Home";
    var mkdocs_page_input_path = "index.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="js/jquery-2.1.1.min.js" defer></script>
  <script src="js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="." class="icon icon-home"> Auditorium</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1 current">
		
    <a class="current" href=".">Home</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#auditorium">Auditorium</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#whats-this-about">What's this about</a></li>
        
            <li><a class="toctree-l3" href="#installation">Installation</a></li>
        
            <li><a class="toctree-l3" href="#quick-start-python-first">Quick Start - Python First</a></li>
        
            <li><a class="toctree-l3" href="#quick-start-markdown-first">Quick Start - Markdown First</a></li>
        
            <li><a class="toctree-l3" href="#whats-the-catch">What's the catch</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="contributing/">Contributing</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="history/">History</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href=".">Auditorium</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".">Docs</a> &raquo;</li>
    
      
    
    <li>Home</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="auditorium">Auditorium</h1>
<p><a href="https://github.com/apiad/auditorium/blob/master/LICENSE"><img alt="PyPI - License" src="https://img.shields.io/pypi/l/auditorium.svg"></a>
<a href="https://pypi.org/project/auditorium/"><img alt="PyPI - Python Version" src="https://img.shields.io/pypi/pyversions/auditorium.svg"></a>
<a href="https://pypi.org/project/auditorium/"><img alt="PyPI" src="https://img.shields.io/pypi/v/auditorium.svg"></a>
<a href="https://travis-ci.org/apiad/auditorium"><img alt="Travis (.org)" src="https://img.shields.io/travis/apiad/auditorium/master.svg"></a>
<a href="https://codecov.io/gh/apiad/auditorium"><img alt="Codecov" src="https://img.shields.io/codecov/c/github/apiad/auditorium.svg"></a>
<a href="https://gitter.im/auditorium-slides/community"><img alt="Gitter" src="https://img.shields.io/gitter/room/apiad/auditorium"></a>
<a href="http://auditorium-demo.apiad.net"><img alt="Demo" src="https://img.shields.io/badge/demo-browse-blueviolet"></img></a></p>
<blockquote>
<p>A Python-powered slideshow creator with steroids.</p>
</blockquote>
<p>See the demo at <a href="http://auditorium-demo.apiad.net">auditorium-demo.apiad.net</a> (sorry, no HTTPS yet).</p>
<h2 id="whats-this-about">What's this about</h2>
<p>Auditorium is a Python-powered slideshow generator.
You write pure Python code, and obtain an HTML+JavaScript slideshow (using the amazing <a href="https://revealjs.com">reveal.js</a> library).
The awesomeness comes from the fact that your Python backend is connected to the slideshow frontend, which allows your slideshow to dynamically change according to user input or automatically.</p>
<p>This opens the door to a few interesting use cases:</p>
<ul>
<li>The slides content itself can be generated by code. For example, long and repetitive sets of slides can be automatically generated, or tables and graphs embedded in slides can be generated on-the-fly with <code>matplotlib</code>, <code>bokeh</code>, <code>altair</code>, <code>plotly</code>, or any visualization package that produces HTML output.</li>
<li>You can insert components in the slides that respond to user input, and execute a Python code in response. For example, you can generate an interactive graph that can be modified by moving sliders in a slideshow.</li>
<li>You can create beautiful animations with simple Python code, that automatically play on a slide, using visualization libraries or simple HTML markup.</li>
</ul>
<blockquote>
<p><strong>And all of this without writing a single line of HTML or JavaScript.</strong></p>
</blockquote>
<p>Alternatively, if you need little to no Python code, you can author your slideshow in pure Markdown and add some Python sprinkless here and there when necessary.</p>
<h2 id="installation">Installation</h2>
<p>Simply run:</p>
<pre><code>pip install auditorium
</code></pre>
<p>To see a quick demo run:</p>
<pre><code>auditorium demo
</code></pre>
<p>And point your browser at <a href="http://localhost:6789">localhost:6789</a>.</p>
<h2 id="quick-start-python-first">Quick Start - Python First</h2>
<p>In <code>auditorium</code> you create a presentation via the <code>Show</code> class:</p>
<pre><code class="python"># Content of &lt;file.py&gt;

from auditorium import Show
show = Show(&quot;My Show&quot;)
</code></pre>

<p>Every slide in your show is a Python method that renders the content and powers the backend logic.
Slides are decorated with the <code>@show.slide</code> decorator.
Every slide receives a <code>ctx</code> parameter, of type <code>Context</code>, which provides the functionalities
that add content, both static and reactive.</p>
<pre><code class="python">@show.slide
def one_slide(ctx):
    # content
</code></pre>

<p>Then run the show:</p>
<pre><code class="bash">auditorium run &lt;file.py&gt;
</code></pre>

<blockquote>
<p><strong>Slides are ordered in the same order in which methods are defined in your script.</strong></p>
</blockquote>
<p>Optionally, you can specify <code>--host</code> and <code>--port</code> as well as <code>--debug</code> which activates hot-reload and outputs debug info (powered by Sanic).</p>
<p>Alternatively, you can also directly call <code>show.run</code>, although the recommended way is the previous one.</p>
<pre><code class="python">show.run('localhost', 6789)
</code></pre>

<p>The simplest possible form of content is static Markdown.
You can add it directly as the docstring of the corresponding slide function,
or calling <code>ctx.markdown</code>.</p>
<pre><code class="python">@show.slide
def static_content(ctx):
    &quot;&quot;&quot;
    ## Static content

    Can be added very simply with:

    * Method _docstrings_
    * Calling `show.markdown`
    &quot;&quot;&quot;

    ctx.markdown(&quot;&gt; Like this&quot;)
</code></pre>

<p>There are several components in <code>auditorium</code> to style and layout your presentation, including reactive components that respond to user input.</p>
<pre><code class="python">@show.slide
def interactive(ctx):
    ctx.markdown(&quot;Enter your name&quot;)
    name = ctx.text_input(default=&quot;World&quot;)
    ctx.markdown(f&quot;&gt; Hello {name}&quot;)
</code></pre>

<p>The slide code is considered stateless, and will be executed every time the input changes.
You should design your slides with this in mind to, for example, provide sensible default values that will work when your presentation first opens.</p>
<p>Simple stateless animations can be created with <code>ctx.animation</code>, which execute the backend code for every frame.
Combining this with drawing logic from, for example, <code>matplotlib</code> allows for very simple animated graphs and visualizations:</p>
<pre><code class="python">@show.slide
def pyplot(ctx):
    with ctx.animation(steps=50, time=0.33, loop=True) as anim:
        # Every 0.33 seconds the graph will move
        step = anim.current * 2 * math.pi / 50
        x = np.linspace(0, 2 * math.pi, 100)
        y = np.sin(x + step) + np.cos(x + step)
        plt.plot(x, y)
        plt.ylim(-2,2)
        ctx.pyplot(plt, fmt='png', height=350)
</code></pre>

<h2 id="quick-start-markdown-first">Quick Start - Markdown First</h2>
<p>Alternatively, if you need little to no Python, you can author your slideshow in pure Markdown. Every level-2 header (<code>##</code>) becomes a slide.</p>
<pre><code class="markdown">## Static content

Static content can be added with pure markdown.

*  Some _markdown_ content.
*  More **markdown** content.
</code></pre>

<p>Pure Markdown can be used as long as all you need is static content. If you need more advanced features, you can add a Python code section anywhere in your slideshow and it will be executed.</p>
<pre><code class="markdown">## Dynamic content

If you need interaction or advanced `auditorium` features,
simply add a code section.

```python :run
with ctx.columns(2) as cl:
    text = ctx.text_input(&quot;World&quot;)

    cl.tab()

    with ctx.success(&quot;Message&quot;):
        ctx.markdown(f&quot;Hello {text}&quot;)
```
</code></pre>

<p>An instance named <code>ctx</code> will be magically available in every Python code section. Beware that <strong>local variables are not persisted</strong> between different code sections. This is a by-design decision to save you a bunch of headaches, believe me.
If you want variables to persist accross code sections, add <code>:persist</code> in the code declaration section. This also let's you interpolate Python variables directly inside the Markdown content.</p>
<pre><code class="markdown">```python  :run :persist
text = ctx.text_input(&quot;World&quot;)
```

Hello {text}. This is pure Markdown.
</code></pre>

<p>You need to add <code>:run</code> to the code section declaration for it to be executed, otherwise <code>auditorium</code> will consider it just Markdown code and simply print it. If you want <strong>both</strong> to run and print the code, then add <code>:run</code> and <code>:echo</code> to the code declaration part.</p>
<p>Once you finished authoring you slideshow, simply run it just like before:</p>
<pre><code class="bash">auditorium run &lt;file.md&gt;
</code></pre>

<p>If you want to see an example, check <a href="auditorium/static/md/demo.md">auditorium/static/md/demo.md</a></p>
<h3 id="going-full-static">Going full static</h3>
<p>If you only need <code>auditorium</code> to generate the HTML, but have no interactive code whatsoever, you can also run:</p>
<pre><code class="bash">auditorium render &lt;file.[py|md]&gt; &gt; &lt;output.html&gt;
</code></pre>

<p>This will render the slideshow in an HTML file with all CSS and JavaScript embedded. Just copy this single HTML file and open it on any browser. You won't need to have <code>auditorium</code> installed. However, do keep in mind that all of the backend code will execute only once for the initial rendering, so your animations will be frozen at the starting frame and none of the interaction will work.</p>
<h2 id="whats-the-catch">What's the catch</h2>
<p>Auditorium covers a fairly simple use case that I haven't seen solved for a long time.
I came up with this idea while trying to make better slideshows for my lectures at the University of Havana.
I usually need to display complex math stuff and graphs, ideally animated, and sometimes make modifications on the fly according to the interaction with students.
They could ask how a function would look if some parameters where changed, etc.</p>
<p>Along that path I grew up from Power Point to JavaScript-based slides (like <a href="https://revealjs.com">reveal.sj</a>) and sometimes even coded some simple behavior in JS, like changing a chart's parameters.
However, for the most complex stuff I wanted to use Python, because otherwise I would need to redo a lot of coding in JS.
For example, I'm teaching compilers now, and I want to show interactively how a parse tree is built for a regular expression.
I simply cannot rewrite my regex engine in JS just for a slideshow.</p>
<p>Then I discovered <a href="https://streamlit.io">streamlit</a> and for a while tried to move my slides to streamlit format.
Streamlit is awesome, but is aimed at a completely different use case.
It's quite cumbersome to force it to behave like a slideshow, the flow is not natural, and the styling options are very restrictive.
On the other hand, they handle a lot of complex scenarios which I simply don't need in a slideshow, like caching and a lot of magic with Pandas and Numpy.
Contrary to streamlit, I do want custom CSS and HTML to be easy to inject, because styling is very important in slides.</p>
<p>So I decided to write my own slideshow generator, just for my simple use cases.
That being said, there are some known deficiencies that I might fix, and some others which I probably will not, even in the long run.</p>
<h3 id="slides-need-to-be-fast">Slides need to be fast</h3>
<p>A slide's code is executed completely every time that slide needs to be rendered.
That is, once during loading and then when inputs change or animations tick.
Hence, you slide logic should be fairly fast.
This is particularly true for animations, so don't expect to be able to train a neural network in real time.
The slide logic is meant to be simple, the kind of one-liners you can run every keystroke, like less than 1 second fast.
If you need to interactively draw the loss value of a neural network, either is gonna take a while or you will have to fake it, i.e., compute it offline and then simply animate it.</p>
<h3 id="all-slides-are-executed-on-load">All slides are executed on load</h3>
<p>For now, on the first load all slides are going to be run, which might increase significantly your loading time if you have complex logic in each slide.
At some point, if I run into the problem, I may add a "lazy" loading option so that only the first few slides are executed.
If this is an issue for a lot of people it might become a priority.</p>
<h3 id="slides-have-to-be-stateless">Slides have to be stateless</h3>
<p>The code that runs inside a slide should not depend on anything outside of <code>ctx</code>, since you have no guarantee when will it be executed.
Right now, slide's code is executed once before any rendering in order to discover vertical slides, then again during the
initial rendering to layout and then everytime an interaction or animation forces the slide to render again.
However, this might be changed at any time, so make no assumptions as to when is that code executed.
The easiest way to do this, is making sure that every slide function is a pure function and all state is handled through
<code>ctx</code> interactive items, such as <code>ctx.text_input</code>.</p>
<h3 id="watch-out-for-code-injection">Watch out for code injection!</h3>
<p>It is very tempting to do things like getting a text from an input box and passing it through <code>eval</code> in Python, so that you can render different functions interactively.
As long as you serve your presentations on <code>localhost</code> and show them yourself, feel free.
However, beware when hosting presentations online.
Since the backend code runs in your computer, a viewer could inject nasty stuff such as importing <code>os</code> and deleting your home folder! In the future I might add a <code>--safe</code> option that only allows for animations and other interactive behaviors that don't use input directly from the user.
Staying away from <code>eval</code> and <code>exec</code> should keep you safe in most scenarios, but the basic suggestion is don't do anything you wouldn't do in a regular web application, since all security issues are the same.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="contributing/" class="btn btn-neutral float-right" title="Contributing">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
        <span style="margin-left: 15px"><a href="contributing/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '.';</script>
    <script src="js/theme.js" defer></script>
      <script src="search/main.js" defer></script>

</body>
</html>

<!--
MkDocs version : 1.0.4
Build Date UTC : 2019-12-26 16:21:12
-->
